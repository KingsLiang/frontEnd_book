## js 基础篇

#### 数组处理函数有哪些？ 创建数组新引用有哪些？(某团)

```
// every(): 数组的每一项都满足给定条件则返回true
var arr = [1, 2, 3, 4, 5];
var everyResult = arr.every(function(item, index, array) {
  return item > 2;
});

console.log(everyResult); // false

// some(): 数组中只需有一项满足给定条件则返回true
var arr = [1, 2, 3, 4, 5];
var everyResult = arr.some(function(item, index, array) {
  return item > 2;
});

console.log(everyResult); // true

// filter(): 返回所有满足给定条件的数据项所组成的新数组
var arr = [1, 2, 3, 4, 5];
var everyResult = arr.filter(function(item, index, array) {
  return item > 2;
});

console.log(everyResult); // [3, 4, 5]
console.log(arr); // [1,2,3,4,5]

// map()：对数组的每一项应用给定条件，返回新的数组
var arr = [1, 2, 3, 4, 5];
var everyResult = arr.map(function(item, index, array) {
  return item * 2;
});

console.log(everyResult); // [2, 4, 6, 8, 10]
console.log(arr); // [1, 2, 3, 4, 5]

// forEach(): 数组遍历，与for循环一样
var arr = [1, 2, 3, 4, 5];
arr.forEach(function(item, index, array) {
// 执行某些操作
});

// 归并方法 reduce()和reduceRight(), 这两个方法只是遍历方向不同
var arr = [1, 2, 3, 4, 5];
var sum = arr.reduce(function(prev, cur, index, array){
  return prev + cur;
}, 0);
// 注意初始值不设的话，遇到空数组会报错
console.log(sum); // 15

```

#### es6 let const 区别？(某团)

let 和 const 的相同点:

1.只在声明所在的块级作用域内有效。

2.不提升，同时存在暂时性死区，只能在声明的位置后面使用。

3.不可重复声明。

let 和 const 的不同点:

1.let 声明的变量可以改变，值和类型都可以改变；const 声明的常量不可以改变，这意味着，const 一旦声明，就必须立即初始化，不能以后再赋值;

```
const i ; // 报错，一旦声明，就必须立即初始化
const j = 5;
j = 10; // 报错，常量不可以改变
```

2.数组和对象等复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const 只保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个复合类型的变量声明为常量必须非常小心

```
const arr = [];
// 报错，[1,2,3]与[]不是同一个地址
arr = [1,2,3];
const arr = [];
// 不报错，变量名arr指向的地址不变，只是数据改变
arr[0] = 1;
arr[1] = 2;
arr[2] = 3;
console.log(arr.length); // 输出：3
// 若想让定义的对象或数组的数据也不能改变，可以使用object.freeze(arr)进行冻结。冻结指的是不能向这个对象或数组添加新的属性，不能修改已有属性的值，不能删除已有属性。
const arr = [];
Object.freeze(arr);
// 不报错，但数据改变无效
arr[0] = 1;
arr[1] = 2;
arr[2] = 3;
console.log(arr.length); // 输出：0
```

#### js 性能优化有哪些？(某团)

整理中...

#### Object 上有哪些常用的函数？(某团)

1.hasOwnProperty(propertyName)

hasOwnProperty 方法接收一个字符串参数，该参数表示属性名称，用来判断该属性是否在当前对象实例中，而不是在对象的原型链中。直白点儿说就是检测当前对象有没有某个属性，返回一个布尔值

```
var arr = [];
console.log(arr.hasOwnProperty("length")); // true
console.log(arr.hasOwnProperty("hasOwnProperty")); // false
```

2.isPrototypeOf(Object)

isPrototype 方法接收一个对象，用来判断当前对象是否在传入的参数对象的原型链上，返回一个布尔值

这个检测的就是 Object 的原型对象是否在 obj 的原型链上，MyObject 是继承自 Object 对象的，而在 JS 中，继承是通过 prototype 来实现的，所以 Object 的 prototype 必定在 MyObject 对象实例的原型链上。所以结果是肯定的

```
function MyObject() {}
var obj = new MyObject();
console.log(Object.prototype.isPrototypeOf(obj)); // true
```

3.propertyIsEnumerable(prototypeName)
prototypeIsEnumerable 用来判断给定的属性是否可以被 for..in 语句给枚举出来(个人感觉可以理解为是否可以被 for..in 语句遍历到)出来，返回一个布尔值

```
var obj = {
  name: "objName"
}
for (var i in obj) {
  console.log(i); // name
}
console.log(obj.propertyIsEnumerable("constructor")); // false
```

执行这段代码输出字符串“name”，这就说明通过 for…in 语句可以得到 obj 的 name 这个属性，但是，obj 的属性还有很多，比如 constructor，比如 hasOwnPrototype 等等，它们并没有被输出，说明这些属性不能被 for…in 给枚举出来，可以通过 propertyIsEnumerable 方法来得到。

4.toLocaleString()

toLocalString 方法返回对象的字符串表示，和代码的执行环境有关。

```
var obj = {};
console.log(obj.toLocaleString()); // [object Object]

var date = new Date();
console.log(date.toLocaleString()); // 2020/4/26 上午11:04:50 输出的就是本地的时间
```

5.toString()
toString 用来返回对象的字符串表示

```
var obj = {};
console.log(obj.toString()); // [object Object]

var date = new Date();
console.log(date.toString()); // Sun Apr 26 2020 11:04:35 GMT+0800 (中国标准时间)
```

6.valueOf()
valueOf 方法返回对象的原始值，根据对象的不同，返回的可能是字符串、数值或 boolean 值等

```
var obj = {
  name: "obj"
};
console.log(obj.valueOf()); // Object {name: "obj"}

var arr = [1];
console.log(arr.valueOf()); // [1]

var date = new Date();
console.log(date.valueOf()); // 1456638436303
```

js 在 Object 常用属性
1.prototype(原型对象)
构造函数有一个 prototype 属性，指向实例对象的原型对象。通过同一个构造函数实例化的多个对象具有相同的原型对象。(经常使用原型对象来实现继承)

```
function Foo() {};
Foo.prototype.a = 1;
var f1 = new Foo;
var f2 = new Foo;

console.log(Foo.prototype.a); // 1
console.log(f1.a); // 1
console.log(f2.a); // 1
```

2.constructor
原型对象有一个 constructor 属性，指向该原型对象对应的构造函数

```
function Foo() {};
console.log(Foo.prototype.constructor === Foo); // true
```

3.\_\_proto\_\_
这个东西并不是标准的原型，它是一些浏览器提供的一个查看 prototype 的接口，多用于调试，prototype 才是标准原型，可用在代码中。

```
function Foo(){};
var f1 = new Foo;
console.log(f1.__proto__ === Foo.prototype); // true
```

#### 如何设计一个模块加载器(某团)

#### 事件委托机制(某站)

#### 事件冒泡，阻止冒泡事件，阻止默认事件(某站)

#### ES6 异步请求方法 promise/async await/generator 等(某站)

#### var let 和 const 区别， 块级作用域(某站)

#### 什么是作用域链 作用域 闭包?(某站)

#### 箭头函数的概念和普通函数的区别?(某站)

#### apply、call、bind 改变 this call 和 apply 与箭头函数有什么区别?(某站)

#### Math 的方法 Math.max Math.min 向上向下取整 Math.ceil Math.floor Math.round(某站)

#### js 的 toFixed 方法(某站)

#### js 的 map 方法(某站)

#### canvas 了解吗 webgl(某站)

#### 油漆桶算法(某站)

#### 最长公共子串怎么实现(某站)

#### null 是什么类型 typeof null(某站)

#### 说说哈希算法(某站)

## css 基础篇

#### css 居中(某团)

#### display:inline-block 为什么会有空白？(某团)

#### 选择器优先级(某团)

#### css 怎么如何渲染到指定 dom 的？(某团)

### 网络请求篇

#### tcp 三次握手(某团)

#### http request 由哪些组成？(某团)

#### 200 304 缓存区别(某团)

#### js 中，不使用 es6 的 promise 异步方法，怎么进行异步请求？(某站)

#### OSI 七层协议、http 是哪个层 tcp/udp 呢(某站)

## 框架基础篇

#### react 生命周期是什么以及干什么？(某团)

#### vue 双向绑定原理(某团)

#### Vue/React 里为什么不能用 index 作为 key(某站)

## 项目工程化篇

##### linux 常用命令(某站)

## 浏览器基础篇

#### localstorage sessionstorage cookie 区别 大小限制？(某团)

##### 生命周期：

cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效

localStorage：除非被手动清除，否则将会永久保存。

sessionStorage： 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。

##### 存放数据大小：

cookie：4KB 左右

localStorage 和 sessionStorage：可以保存 5MB 的信息。

##### http 请求：

cookie：每次都会携带在 HTTP 头中，如果使用 cookie 保存过多数据会带来性能问题

localStorage 和 sessionStorage：仅在客户端（即浏览器）中保存，不参与和服务器的通信

##### 易用性：

cookie：需要程序员自己封装，源生的 Cookie 接口不友好

localStorage 和 sessionStorage：源生接口可以接受，亦可再次封装来对 Object 和 Array 有更好的支持

##### 应用场景：

从安全性来说，因为每次 http 请求都会携带 cookie 信息，这样无形中浪费了带宽，所以 cookie 应该尽可能少的使用，另外 cookie 还需要指定作用域，不可以跨域调用，限制比较多。但是用来识别用户登录来说，cookie 还是比 storage 更好用的。其他情况下，可以使用 storage

localStorage 和 sessionStorage 唯一的差别一个是永久保存在浏览器里面，一个是关闭网页就清除了信息。

localStorage 可以用来夸页面传递参数，sessionStorage 用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。

##### 浏览器支持情况：

localStorage 和 sessionStorage 是 html5 才应用的新特性，可能有些浏览器并不支持，IE8+

cookie 可以通过下面这段代码来判断所使用的浏览器是否支持 cookie

```
if(navigator.cookieEnabled) {
  alert("该浏览器支持cookie"); // 浏览器支持cookie
} else {
  alert("该浏览器不支持cookie"); // 浏览器不支持cookie
}

```

#### 跨域的问题 说了 jsonp domain cors postmessage，iframe 怎么在开发中实现跨域不在后端设置(node)(某站)

#### 浏览器从输入 URL 到渲染完页面的整个过程 越详细越好(某站)

#### 介绍一下对浏览器内核的理解 v8 引擎(某站)

#### 缓存 浏览器缓存 http 缓存(某站)

## 手写代码篇

#### 考察 new 和闭包(某节)

```
// 不使用全局变量前提下实现如下逻辑
let a = new Foo() //a.id -> 1
let b = new Foo() //b.id -> 2

// 使用闭包
const Foo = (function() {
  let index = 1;
  return function() {
    this.id = index++;
  }
})();

let a = new Foo() // a.id -> 1
let b = new Foo() // b.id -> 2

// 增加难度,考察`new`和直接调用的区别
let a = Foo() // a.id -> 1
let b = new Foo() // b.id -> 2
let c = new Foo() // c.id -> 3
let d = Foo() // d.id -> 4

// 分析
// d就是函数Foo()执行的返回值，没有返回值也就是undefined. 在函数执行过程中，属性被加到全局作用域或者Foo方法所属的对象上
// 考察对new的理解，new会改变this指向，指向实例化的实例，那我们就可以使用instanceof判断了

const Foo = (function() {
  let index = 1;
  return function() {
    if(this instanceof Foo) {
      // 使用new
      this.id = index++;
    }else {
      // 没有使用new, 直接返回一个对象
      return {
        id: index++
      }
    }
  }
})();

let a = Foo() // a.id -> 1
let b = new Foo() // b.id -> 2
let c = new Foo() // c.id -> 3
let d = Foo() // d.id -> 4

```

#### 写一个正则匹配字符转成驼峰？(某团)

实现: border-bottom-color 》 borderBottomColor

```
let str = "border-bottom-color";

// 使用正则
// 通过正则找到-b  -c。默认的是匹配一次，所以要用g来全局匹配。
// \w指的字符, $0代表正则，$1代表指向, replace替换就是B替换-b

function toCaml(str) {
  let reg = /-(\w)/g;
  return str.replace(reg, function($0, $1){
    return $1.toUpperCase();
  });
}

console.log(toCaml(str));

// for循环
// 用split()函数来进行分割字符串arr里面包括
function test(str) {
  var arr = str.split("-");
  // 从数组的第二项开始循环，charAt(0)找到第一个字母。substring(1)截掉第一个字母
  for(let i = 1; i < arr.length; i++) {
    arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].substring(1);
  }
  return arr.join("");
}

console.log(test(str));
```

扩展：驼峰转连字符

```
let str = 'strArrTest';
function test(str) {
  let str1 = str.replace(/([A-Z])/g, function ($1) {
    return '-' + $1.toLocaleLowerCase();
  });
  return str1;
}

console.log(test(str));

```

#### 实现一个 ajax 方法(某站)

## git 基础篇

#### 在 A 分支写代码，B 分支出了 Bug 怎么切换到 B 分支，在不 commit 和注释的情况下 (某站)

git stash

#### 第一次 commit 第二次 commit 发现实际上只需要压缩合并两次提交的就好了，用哪个命令?(某站)

git rebase -i
