### js 基础篇

#### 数组处理函数有哪些？ 创建数组新引用有哪些？(某团)

#### es6 let const 区别？(某团)

#### localstorage sessionstorage cookie 区别 大小限制？(某团)

#### js 性能优化有哪些？(某团)

#### Object 上有哪些常用的函数？(某团)

#### 正则匹配字符转成驼峰？(某团)

#### 如何设计一个模块加载器(某团)

#### tcp 三次握手(某团)

#### http request 由哪些组成？(某团)

#### 200 304 缓存区别(某团)

#### 事件委托机制(某站)

#### 事件冒泡，阻止冒泡事件，阻止默认事件(某站)

#### js 中，不使用 es6 的 promise 异步方法，怎么进行异步请求？(某站)

#### ES6 异步请求方法 promise/async await/generator 等(某站)

#### var let 和 const 区别， 块级作用域(某站)

#### 什么是作用域链 作用域 闭包?(某站)

#### 箭头函数的概念和普通函数的区别?(某站)

#### apply、call、bind 改变 this call 和 apply 与箭头函数有什么区别?(某站)

#### Math 的方法 Math.max Math.min 向上向下取整 Math.ceil Math.floor Math.round(某站)

#### js 的 toFixed 方法(某站)

#### js 的 map 方法(某站)

#### 跨域的问题 说了 jsonp domain cors postmessage，iframe 怎么在开发中实现跨域不在后端设置(node)(某站)

#### canvas 了解吗 webgl(某站)

#### 油漆桶算法(某站)

#### git 的场景提，在 A 分支写代码，B 分支出了 Bug 怎么切换到 B 分支，在不 commit 和注释的情况下 git stash(某站)

#### git 常用的命令，第一次 commit 第二次 commit 发现实际上只需要压缩合并两次提交的就好了，用哪个命令 git rebase -i(某站)

#### git 常用的命令，第一次 commit 第二次 commit 发现实际上只需要压缩合并两次提交的就好了，用哪个命令 git rebase -i(某站)

#### 最长公共子串怎么实现(某站)

#### OSI 七层协议、http 是哪个层 tcp/udp 呢(某站)

#### null 是什么类型 typeof null(某站)

#### 说说哈希算法(某站)

### css 基础篇

#### css 居中(某团)

#### display:inline-block 为什么会有空白？(某团)

#### 选择器优先级(某团)

#### css 怎么如何渲染到指定 dom 的？(某团)

### 框架基础篇

#### react 生命周期是什么以及干什么？(某团)

#### vue 双向绑定原理(某团)

#### Vue/React 里为什么不能用 index 作为 key(某站)

### 项目工程化篇

##### linux 常用命令(某站)

### 浏览器基础篇

#### 浏览器从输入 URL 到渲染完页面的整个过程 越详细越好(某站)

#### 介绍一下对浏览器内核的理解 v8 引擎(某站)

#### 缓存 浏览器缓存 http 缓存(某站)

### 手写代码篇

#### 1.考察 new 和闭包(某节)

```
// 不使用全局变量前提下实现如下逻辑
let a = new Foo() //a.id -> 1
let b = new Foo() //b.id -> 2

// 使用闭包
const Foo = (function() {
  let index = 1;
  return function() {
    this.id = index++;
  }
})();

let a = new Foo() // a.id -> 1
let b = new Foo() // b.id -> 2

// 增加难度,考察`new`和直接调用的区别
let a = Foo() // a.id -> 1
let b = new Foo() // b.id -> 2
let c = new Foo() // c.id -> 3
let d = Foo() // d.id -> 4

// 分析
// d就是函数Foo()执行的返回值，没有返回值也就是undefined. 在函数执行过程中，属性被加到全局作用域或者Foo方法所属的对象上
// 考察对new的理解，new会改变this指向，指向实例化的实例，那我们就可以使用instanceof判断了

const Foo = (function() {
  let index = 1;
  return function() {
    if(this instanceof Foo) {
      // 使用new
      this.id = index++;
    }else {
      // 没有使用new, 直接返回一个对象
      return {
        id: index++
      }
    }
  }
})();

let a = Foo() // a.id -> 1
let b = new Foo() // b.id -> 2
let c = new Foo() // c.id -> 3
let d = Foo() // d.id -> 4

```

#### 实现一个 ajax 方法(某站)
