### js 基础篇

#### 数组处理函数有哪些？ 创建数组新引用有哪些？(某团)

```
// every(): 数组的每一项都满足给定条件则返回true
var arr = [1, 2, 3, 4, 5];
var everyResult = arr.every(function(item, index, array) {
  return item > 2;
});

console.log(everyResult); // false

// some(): 数组中只需有一项满足给定条件则返回true
var arr = [1, 2, 3, 4, 5];
var everyResult = arr.some(function(item, index, array) {
  return item > 2;
});

console.log(everyResult); // true

// filter(): 返回所有满足给定条件的数据项所组成的新数组
var arr = [1, 2, 3, 4, 5];
var everyResult = arr.filter(function(item, index, array) {
  return item > 2;
});

console.log(everyResult); // [3, 4, 5]
console.log(arr); // [1,2,3,4,5]

// map()：对数组的每一项应用给定条件，返回新的数组
var arr = [1, 2, 3, 4, 5];
var everyResult = arr.map(function(item, index, array) {
  return item * 2;
});

console.log(everyResult); // [2, 4, 6, 8, 10]
console.log(arr); // [1, 2, 3, 4, 5]

// forEach(): 数组遍历，与for循环一样
var arr = [1, 2, 3, 4, 5];
arr.forEach(function(item, index, array) {
// 执行某些操作
});

// 归并方法 reduce()和reduceRight(), 这两个方法只是遍历方向不同
var arr = [1, 2, 3, 4, 5];
var sum = arr.reduce(function(prev, cur, index, array){
  return prev + cur;
}, 0);
// 注意初始值不设的话，遇到空数组会报错
console.log(sum); // 15

```

#### es6 let const 区别？(某团)

let 和 const 的相同点:

1.只在声明所在的块级作用域内有效。

2.不提升，同时存在暂时性死区，只能在声明的位置后面使用。

3.不可重复声明。

let 和 const 的不同点:

1.let 声明的变量可以改变，值和类型都可以改变；const 声明的常量不可以改变，这意味着，const 一旦声明，就必须立即初始化，不能以后再赋值;

```
const i ; // 报错，一旦声明，就必须立即初始化
const j = 5;
j = 10; // 报错，常量不可以改变
```

2.数组和对象等复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const 只保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个复合类型的变量声明为常量必须非常小心

```
const arr = [];
// 报错，[1,2,3]与[]不是同一个地址
arr = [1,2,3];
const arr = [];
// 不报错，变量名arr指向的地址不变，只是数据改变
arr[0] = 1;
arr[1] = 2;
arr[2] = 3;
console.log(arr.length); // 输出：3
// 若想让定义的对象或数组的数据也不能改变，可以使用object.freeze(arr)进行冻结。冻结指的是不能向这个对象或数组添加新的属性，不能修改已有属性的值，不能删除已有属性。
const arr = [];
Object.freeze(arr);
// 不报错，但数据改变无效
arr[0] = 1;
arr[1] = 2;
arr[2] = 3;
console.log(arr.length); // 输出：0
```

#### localstorage sessionstorage cookie 区别 大小限制？(某团)

##### 生命周期：

cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效

localStorage：除非被手动清除，否则将会永久保存。

sessionStorage： 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。

##### 存放数据大小：

cookie：4KB 左右

localStorage 和 sessionStorage：可以保存 5MB 的信息。

##### http 请求：

cookie：每次都会携带在 HTTP 头中，如果使用 cookie 保存过多数据会带来性能问题

localStorage 和 sessionStorage：仅在客户端（即浏览器）中保存，不参与和服务器的通信

##### 易用性：

cookie：需要程序员自己封装，源生的 Cookie 接口不友好

localStorage 和 sessionStorage：源生接口可以接受，亦可再次封装来对 Object 和 Array 有更好的支持

##### 应用场景：

从安全性来说，因为每次 http 请求都会携带 cookie 信息，这样无形中浪费了带宽，所以 cookie 应该尽可能少的使用，另外 cookie 还需要指定作用域，不可以跨域调用，限制比较多。但是用来识别用户登录来说，cookie 还是比 storage 更好用的。其他情况下，可以使用 storage

localStorage 和 sessionStorage 唯一的差别一个是永久保存在浏览器里面，一个是关闭网页就清除了信息。

localStorage 可以用来夸页面传递参数，sessionStorage 用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。

##### 浏览器支持情况：

localStorage 和 sessionStorage 是 html5 才应用的新特性，可能有些浏览器并不支持，IE8+

cookie 可以通过下面这段代码来判断所使用的浏览器是否支持 cookie

```
if(navigator.cookieEnabled) {
  alert("该浏览器支持cookie"); // 浏览器支持cookie
} else {
  alert("该浏览器不支持cookie"); // 浏览器不支持cookie
}

```

#### js 性能优化有哪些？(某团)

#### Object 上有哪些常用的函数？(某团)

#### 正则匹配字符转成驼峰？(某团)

#### 如何设计一个模块加载器(某团)

#### tcp 三次握手(某团)

#### http request 由哪些组成？(某团)

#### 200 304 缓存区别(某团)

#### 事件委托机制(某站)

#### 事件冒泡，阻止冒泡事件，阻止默认事件(某站)

#### js 中，不使用 es6 的 promise 异步方法，怎么进行异步请求？(某站)

#### ES6 异步请求方法 promise/async await/generator 等(某站)

#### var let 和 const 区别， 块级作用域(某站)

#### 什么是作用域链 作用域 闭包?(某站)

#### 箭头函数的概念和普通函数的区别?(某站)

#### apply、call、bind 改变 this call 和 apply 与箭头函数有什么区别?(某站)

#### Math 的方法 Math.max Math.min 向上向下取整 Math.ceil Math.floor Math.round(某站)

#### js 的 toFixed 方法(某站)

#### js 的 map 方法(某站)

#### 跨域的问题 说了 jsonp domain cors postmessage，iframe 怎么在开发中实现跨域不在后端设置(node)(某站)

#### canvas 了解吗 webgl(某站)

#### 油漆桶算法(某站)

#### git 的场景提，在 A 分支写代码，B 分支出了 Bug 怎么切换到 B 分支，在不 commit 和注释的情况下 git stash(某站)

#### git 常用的命令，第一次 commit 第二次 commit 发现实际上只需要压缩合并两次提交的就好了，用哪个命令 git rebase -i(某站)

#### git 常用的命令，第一次 commit 第二次 commit 发现实际上只需要压缩合并两次提交的就好了，用哪个命令 git rebase -i(某站)

#### 最长公共子串怎么实现(某站)

#### OSI 七层协议、http 是哪个层 tcp/udp 呢(某站)

#### null 是什么类型 typeof null(某站)

#### 说说哈希算法(某站)

### css 基础篇

#### css 居中(某团)

#### display:inline-block 为什么会有空白？(某团)

#### 选择器优先级(某团)

#### css 怎么如何渲染到指定 dom 的？(某团)

### 框架基础篇

#### react 生命周期是什么以及干什么？(某团)

#### vue 双向绑定原理(某团)

#### Vue/React 里为什么不能用 index 作为 key(某站)

### 项目工程化篇

##### linux 常用命令(某站)

### 浏览器基础篇

#### 浏览器从输入 URL 到渲染完页面的整个过程 越详细越好(某站)

#### 介绍一下对浏览器内核的理解 v8 引擎(某站)

#### 缓存 浏览器缓存 http 缓存(某站)

### 手写代码篇

#### 1.考察 new 和闭包(某节)

```
// 不使用全局变量前提下实现如下逻辑
let a = new Foo() //a.id -> 1
let b = new Foo() //b.id -> 2

// 使用闭包
const Foo = (function() {
  let index = 1;
  return function() {
    this.id = index++;
  }
})();

let a = new Foo() // a.id -> 1
let b = new Foo() // b.id -> 2

// 增加难度,考察`new`和直接调用的区别
let a = Foo() // a.id -> 1
let b = new Foo() // b.id -> 2
let c = new Foo() // c.id -> 3
let d = Foo() // d.id -> 4

// 分析
// d就是函数Foo()执行的返回值，没有返回值也就是undefined. 在函数执行过程中，属性被加到全局作用域或者Foo方法所属的对象上
// 考察对new的理解，new会改变this指向，指向实例化的实例，那我们就可以使用instanceof判断了

const Foo = (function() {
  let index = 1;
  return function() {
    if(this instanceof Foo) {
      // 使用new
      this.id = index++;
    }else {
      // 没有使用new, 直接返回一个对象
      return {
        id: index++
      }
    }
  }
})();

let a = Foo() // a.id -> 1
let b = new Foo() // b.id -> 2
let c = new Foo() // c.id -> 3
let d = Foo() // d.id -> 4

```

#### 实现一个 ajax 方法(某站)
